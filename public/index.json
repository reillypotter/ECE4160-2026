
[{"content":"I\u0026rsquo;m Reilly Potter, a junior majoring in Electrical and Computer Engineering with a minor in Robotics. I\u0026rsquo;m interested in assistive robotics and the future of prosthetics. I enjoy playing the drums and video games in my free time.\n","date":"25 February 2026","externalUrl":null,"permalink":"/ECE4160-2026/","section":"About","summary":"","title":"About","type":"page"},{"content":"\rPrelab\r#\rThe goal of this lab was to set up the time of flight sensors prepare them for the RC car\u0026rsquo;s use in detecting obstacles. By placing a sensor at the front of the car and one on the side, the car is able to detect obstacles in front of it as well as on the right side. This allows it to hve better understanding of where it can trun without needing to rotate 90° in order to check for obstacles. This does mean however, the car can\u0026rsquo;t see anything behind as well as leaving the possibility for obstacles to be hit on the edges of the front. With the sensor in the middle of the front, it can\u0026rsquo;t feel capture the width of the car.\nBoth ToF sensors have the same I2C address of 0x52 according to the datasheet, so to use both of them, I had to change the address of one on the programs start or cycle the sensors on and off. I opted to change the address of one so I can gather data from the two sensors simultaneously. I also connected the sensors to the longer QWIIC cables so they can easil be placed in front and side fo the car, respectively, while the IMU is connected to a shorter cable. Schematic for Tof/IMU circuit. Note: a 850mAh battery is depicted but a 750mAh battery is used for the circuit.\rBattery Setup\r#\rI had to connect a JST connector to a 750mAh battery for use with the Artemis Nano. The black lead of the battery had to be solder to the red of the connector and the red lead to the black for it to connect to the Artemis correctly. Heat shrink was used to cover the solder connecting the battery to the JST connector. Battery soldered to JST connector\rToF Setup\r#\rI started by installing the SparkFun VL53L1X 4m laser distance sensor library and connecting the first ToF sensor to a QWIIC cable. I used a longer cable while referencing the datasheet to solder it, and the blue connected to SDA while the yellow connected to SCL. ToF sensor soldered and connected to QWIIC breakout and Artemis\rI then ran the Example1_wire_I2C to test that the sensor was connected properly. I2C address for the ToF sensor\rThis address is different from what I expected as the datasheet says the default is 0x52, but the example shows the address as 0x29. When looking at the binary values, you see 0x29 is 00101001 and 0x52 is 01010010. This shows that the value was shifted right by one bit, and this is due to the fact the least significant bit of the 0x52 address is used for read/write.\rToF Testing\r#\rNext, I used Example1_ReadDistance to test the functionality of the ToF sensor. It has three distinct modes: short, medium, and long. Medium requires another library, so I focused on short and long. Short provides ranges up to 1.3m while long provides up to 4m. Long is very susceptible to ambient light according to the datasheet with it only allowing for ~0.7m under strong light. Short keeps its 1.3m range despite any strong light. Medium is very similar to long except its max range is shorter. These make short seem like the most relibale mode as the lighting conditions can be hard to control for the car.\nBoth ToF\u0026rsquo;s\r#\rToF Execution Speed\r#\rToF and IMU Testing\r#\r","date":"25 February 2026","externalUrl":null,"permalink":"/ECE4160-2026/labs/lab3/","section":"Labs","summary":"","title":"Lab 3: Time of Flight Sensors","type":"labs"},{"content":"","date":"25 February 2026","externalUrl":null,"permalink":"/ECE4160-2026/labs/","section":"Labs","summary":"","title":"Labs","type":"labs"},{"content":"\rIMU Setup\r#\rAD0_VAL represents the last bit of the I2C address. The default value for this is 1, and it should not be changed unless the ADR jumper is closed via solder to which it should then be set to 0.\nAs the IMU is being rotated, you can see that the accelerometer and gyrometer print data as expected. All three axes for the sensors are printed along with their corresponding units. You can see accelerations and rotations being tracked and printed, but absolute position is not represented as changes in printed values only occur with movement. When rotating about the z-axis, the accelerometer does not change values but the gyrometer does and vice-versa for the x-axis.\nAccelerometer\r#\r0° Pitch, 0° Roll\r90° Pitch, 0° Roll\r-90° Pitch, 0° Roll\r0° Pitch, 90° Roll\r0° Pitch, -90° Roll\rGyrometer\r#\rSampling Data\r#\rStunt!\r#\rRC Car Stunt\rThe car is able to move very quickly with rapid accelerations. The traction of the car greatly depends on what surface you\u0026rsquo;re driving on, and when driving on tile, there\u0026rsquo;s very little traction. When driving fast, you can easily make the car flip and bounce around due to high speeds.\n","date":"17 February 2026","externalUrl":null,"permalink":"/ECE4160-2026/labs/lab2/","section":"Labs","summary":"","title":"Lab 2: The IMU","type":"labs"},{"content":"\r1a\r#\rFor section 1A, I had to install the Arduino IDE and connect to the Artemis Nano microcontroller. I connected to the Artemis board using a USB cable to where I then selected the board through the Arduino IDE and tested various examples from the IDE.\nBlink\r#\rThe Artemis board flashes a blue LED every second.\nBlink test\rSerial\r#\rHere we can see the Artemis recieves the string and echos it back Serial output test\ranalogRead Temperature Sensor\r#\rAs I hold the board, the temperature increases from consistent 33100 readings to 33300 readings.\nTemperature sensor test\rMicrophone Output\r#\rYou can see the values of ambient noise and then a jump in frequency as I provide sound.\nMicrophone test\r1b\r#\rCodebase and BLE\r#\rBluetooth Low Energy is used for the connection between my latop and Artemis board.\nBLE radio acts like a community bulletin board where computers act ascommunity members and can connect to read the board. If the radio is a bulletin board, it\u0026rsquo;s called a peripheral device. The Artemis scts as the bulletin board and is responsible for posting data. If the radio is a reader it reads from any of the bulletin boards.\nA peripheral provides services, which in turn provides characteristics. Services are identified by unique numbers known as UUIDs. Bluetooth acts on mulitple layers, and the General Attribute Profile (GATT) is what defines services and characteristics.\nThe codebase has various Python and Arduino packages along with code files to help establish a Bluetooth connection with the Artemis board.\nImportant functions used to communicate between the computer and Artemis: send_command(cmd_type, data) to send a command ble.connect() and ble.disconnect to connect with the Artemis receive_string(uuid) to recieve a string from our board start_notify(uuid, notification_handler) to activate the notification handler Configurations and Setup\r#\rI installed venv: python3 -m pip install --user virtualenv\nI created the \u0026ldquo;FastRobots_ble\u0026rdquo; virtual environment: python3 -m venv FastRobots_ble\nI activated the virtual environment: source FastRobots_ble/bin/activate\nI downloaded python packages: pip install numpy pyyaml colorama nest_asyncio bleak jupyterlab and the provided ble_robot_1.4 codebase into my project directory\nThen I started the Jupyter server: jupyter lab\nI updated the Artemis MAC Address in connections.yaml using the provided one: artemis_address: 'C0:C2:8A:89:98:08'\nI generated a new UUID: run from uuid import uuid4 and uuid4(). I input the generated UUID into the #define BLE_UUID_TEST_SERVICE line in ble_arduino.ino and into the ble_service: line in connections.yaml\nNew UUID\rConnect to the Artemis Nano via BLE ble = get_ble_controller() ble.connect()\rSuccessful BLE Connection\rTask 1\r#\rI sent a string value from my computer to the Artemis board using the ECHO command and the computer recieved and printed the string.\nArduino Code:\ncase ECHO: char char_arr[MAX_MSG_SIZE]; // Extract the next value from the command string as a character array success = robot_cmd.get_next_value(char_arr); if (!success) return; Serial.print(\u0026#34;Robot says -\u0026gt; \u0026#34;); Serial.print(char_arr); Serial.println(\u0026#34; :)\u0026#34;); break;\rJupyter Code:\nble.send_command(CMD.ECHO, \u0026#34;Hello\u0026#34;) ble.send_command(CMD.ECHO, \u0026#34;HiHello\u0026#34;)\rECHO Output\rTask 2\r#\rI sent three floats to the Artemis board using the SEND_THREE_FLOATS command and extracted the three floats in the Arduino sketch\nArduino Code:\ncase SEND_THREE_FLOATS: float float_a, float_b, float_c; // Extract the next value from the command string as an float success = robot_cmd.get_next_value(float_a); if (!success) return; // Extract the next value from the command string as an float success = robot_cmd.get_next_value(float_b); if (!success) return; // Extract the next value from the command string as an float success = robot_cmd.get_next_value(float_c); if (!success) return; Serial.print(\u0026#34;Three Floats: \u0026#34;); Serial.print(float_a); Serial.print(\u0026#34;, \u0026#34;); Serial.print(float_b); Serial.print(\u0026#34;, \u0026#34;); Serial.println(float_c); break;\rJupyter Code:\nble.send_command(CMD.SEND_THREE_FLOATS, \u0026#34;3.6|-4.55|12.938\u0026#34;)\rSEND_THREE_FLOATS Output\rTask 3\r#\rI added a GET_TIME_MILLIS command which makes the robot reply write a string to the string characteristic. This has the same output as shown in Task 4.\ncase GET_TIME_MILLIS: tx_estring_value.clear(); tx_estring_value.append(\u0026#34;T:\u0026#34;); tx_estring_value.append((int) millis()); tx_characteristic_string.writeValue(tx_estring_value.c_str()); Serial.print(\u0026#34;Sent back: \u0026#34;); Serial.println(tx_estring_value.c_str()); break;\rTask 4\r#\rI setup a notification_handler function to receive the string value from the Artemis board and, in the callback function, extract the time from the string.\nJupyter Code:\ndef notification_handler(uuid, notif): string = ble.bytearray_to_string(notif) print(string)\rble.start_notify(ble.uuid[\u0026#39;RX_STRING\u0026#39;], notification_handler) ble.send_command(CMD.GET_TIME_MILLIS, \u0026#34;time\u0026#34;)\rNotification Handler Output\rTask 5\r#\rI made a loop called GET_TIME_LOOP that gets the current time over 5 seconds using the GET_TIME_MILLIS function to then be processed by notification_handler(). With this method, I took the first and last time received by my notification handler and changed the time difference into a byte rate. From this I got a byte rate of 80 bytes per second.\nArduino Code:\ncase GET_TIME_LOOP: int starting_millis; starting_millis = (int) millis(); while ((int) millis() - starting_millis \u0026lt; 5000) { tx_estring_value.clear(); tx_estring_value.append(\u0026#34;T:\u0026#34;); tx_estring_value.append((int) millis()); tx_characteristic_string.writeValue(tx_estring_value.c_str()); Serial.print(\u0026#34;Sent back: \u0026#34;); Serial.println(tx_estring_value.c_str()); } break;\rJupyter Code:\nble.start_notify(ble.uuid[\u0026#39;RX_STRING\u0026#39;], notification_handler) ble.send_command(CMD.GET_TIME_LOOP, \u0026#34;loop\u0026#34;)\rbyte_rate = 400 / ((356529 - 351554) / 1000) print(byte_rate)\rGET_TIME_MILLIS Loop Output\rTask 6\r#\rI created a command SEND_TIME_DATA that loops through to add generated time steps via the millis() function to an array. Then, in GET_ARRAY I loop through the array and send each data point as a string to my laptop. time_array[TIME_SAMPLES] is defined as a global array where TIME_SAMPLES = 1000.\nArduino Code:\ncase GET_TIME_ARRAY: int i; for (i = 0; i \u0026lt; TIME_SAMPLES; i++) { time_array[i] = (int) millis(); } Serial.print(i); Serial.println(\u0026#34; time samples received.\u0026#34;); break; case SEND_TIME_DATA: int j; for (j = 0; j \u0026lt; TIME_SAMPLES; j++) { tx_estring_value.clear(); tx_estring_value.append(\u0026#34;T:\u0026#34;); tx_estring_value.append(time_array[j]); tx_characteristic_string.writeValue(tx_estring_value.c_str()); } Serial.print(\u0026#34;Sent back: \u0026#34;); Serial.print(j); Serial.println(\u0026#34; messages.\u0026#34;); break;\rJupyter Code:\nble.start_notify(ble.uuid[\u0026#39;RX_STRING\u0026#39;], notification_handler) ble.send_command(CMD.GET_TIME_ARRAY, \u0026#34;array\u0026#34;) ble.send_command(CMD.SEND_TIME_DATA, \u0026#34;data\u0026#34;)\rSEND_TIME_DATA Output\rTask 7\r#\rI created a second array to store temperature readings with the same length as the one used in Task 6. The command GET_TEMP_READINGS loops through both arrays concurrently and sends each temperature reading with a time stamp. The notification handler parses these strings and populates the data into two lists. GET_ARRAY was also changed to GET_ARRAYS to add in the new temperature array.\nArduino Code:\ncase GET_ARRAYS: int i; for (i = 0; i \u0026lt; TIME_SAMPLES; i++) { time_array[i] = (int) millis(); temp_array[i] = (int) getTempDegF(); } Serial.print(i); Serial.println(\u0026#34; time samples received.\u0026#34;); break; case GET_TEMP_READINGS: for (i = 0; i \u0026lt; TIME_SAMPLES; i++) { tx_estring_value.clear(); tx_estring_value.append(\u0026#34;Temp: \u0026#34;); tx_estring_value.append(temp_array[i]); tx_estring_value.append(\u0026#34; at time:\u0026#34;); tx_estring_value.append(time_array[i]); tx_characteristic_string.writeValue(tx_estring_value.c_str()); } Serial.print(\u0026#34;Sent back: \u0026#34;); Serial.print(i); Serial.println(\u0026#34; messages.\u0026#34;); break;\rJupyter Code:\nble.start_notify(ble.uuid[\u0026#39;RX_STRING\u0026#39;], notification_handler) ble.send_command(CMD.GET_ARRAYS, \u0026#34;array\u0026#34;) ble.send_command(CMD.GET_TEMP_READINGS, \u0026#34;temp\u0026#34;)\rTemp and Time Arrays Output\rTask 8\r#\rTask 5\u0026rsquo;s method is clearly slower than Task 6\u0026rsquo;s as Task 5 requires the Artemis to send its data to the computer after every measurement before it can record again. Task 6 is able to record all the data at once before sending it to the computer, but it does introduce a delay in reception of data. This can mean a slower response time, so it is not as applicable for time sensitive decisions. When not caring about feedback as much, this method can be more useful as the lack of a delay allows for more accurate data over the given amount of time.\nFor Task 6\u0026rsquo;s method the first element is T: 146591ms and the 1000th is T: 146608ms which is equivalent to data being transferred every 0.017ms. This is considerably faster than the time it took in Task 5.\nBoth millis() and getTempDegF() stored as ints with 4 bytes each for a total of 8 bytes. The Arduino IDE shows that global variables use 30648 bytes, so if the Artemis board has 384 kB of RAM, then 353,352 bytes remain allowing us to store a total of 353,352 bytes/8 bytes = 44,169 data points without running out of memory.\nDiscussion\r#\rIn this lab, I learned about the functions used to communicate to the Artemis over bluetooth and how I\u0026rsquo;m able to modify them. Understanding certain parts of the BLE library like the characteristics was confusing at first, but as I worked through the lab I understood their purpose more. The largest problem I faced during this lab was trying to figure out how to define certain things such as the notification handler or some of my implementations like the arrays. Collaboration\r#\rI referenced Lucca\u0026rsquo;s site for inital help developing and formatting my website. I also used ChatGPT to help me figure out some documentation for my site.\n","date":"10 February 2026","externalUrl":null,"permalink":"/ECE4160-2026/labs/lab1/","section":"Labs","summary":"","title":"Lab 1: The Artemis board and Bluetooth","type":"labs"},{"content":"","externalUrl":null,"permalink":"/ECE4160-2026/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/ECE4160-2026/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/ECE4160-2026/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/ECE4160-2026/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]